--- a/drivers/char/random.c	2021-07-02 14:36:06.296620635 -0300
+++ b/drivers/char/random.c	2021-07-02 15:39:58.747655917 -0300
@@ -133,6 +133,8 @@
  *                                unsigned int value);
  *	void add_interrupt_randomness(int irq, int irq_flags);
  * 	void add_disk_randomness(struct gendisk *disk);
+ *  void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+ *  int random_input_wait(void);
  *
  * add_device_randomness() is for adding data to the random pool that
  * is likely to differ between two devices (or possibly even per boot).
@@ -155,6 +157,13 @@
  * seek times do not make for good sources of entropy, as their seek
  * times are usually fairly consistent.
  *
+ * random_input_words() just provides a raw block of entropy to the input
+ * pool, such as from a hardware entropy generator.
+ *
+ * random_input_wait() suspends the caller until such time as the
+ * entropy pool falls below the write threshold, and returns a count of how
+ * much entropy (in bits) is needed to sustain the pool.
+ *
  * All of these routines try to estimate how many bits of randomness a
  * particular randomness source.  They do this by keeping track of the
  * first and second order deltas of the event timings.
@@ -1299,6 +1308,62 @@
 EXPORT_SYMBOL_GPL(add_disk_randomness);
 #endif
 
+
+/*
+ * random_input_words - add bulk entropy to pool
+ *
+ * @buf: buffer to add
+ * @wordcount: number of __u32 words to add
+ * @ent_count: total amount of entropy (in bits) to credit
+ *
+ * this provides bulk input of entropy to the input pool
+ *
+ */
+void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+{
+	mix_pool_bytes(&input_pool, buf, wordcount*4 );
+
+	credit_entropy_bits(&input_pool, ent_count);
+
+	//DEBUG_ENT("crediting %d bits => %d\n",
+	//	  ent_count, input_pool.entropy_count);
+	/*
+	 * Wake up waiting processes if we have enough
+	 * entropy.
+	 */
+	if (input_pool.entropy_count >= random_read_wakeup_bits)
+		wake_up_interruptible(&random_read_wait);
+}
+EXPORT_SYMBOL(random_input_words);
+
+/*
+ * random_input_wait - wait until random needs entropy
+ *
+ * this function sleeps until the /dev/random subsystem actually
+ * needs more entropy, and then return the amount of entropy
+ * that it would be nice to have added to the system.
+ */
+int random_input_wait(void)
+{
+	int count;
+
+	wait_event_interruptible(random_write_wait, 
+			 input_pool.entropy_count < random_write_wakeup_bits);
+
+	count = random_write_wakeup_bits - input_pool.entropy_count;
+
+        /* likely we got woken up due to a signal */
+	if (count <= 0) count = random_read_wakeup_bits; 
+
+	//DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
+	//	  count,
+	//	  input_pool.entropy_count, random_write_wakeup_bits);
+
+	return count;
+}
+EXPORT_SYMBOL(random_input_wait);
+
+
 /*********************************************************************
  *
  * Entropy extraction routines
diff -Nuar a/include/linux/miscdevice.h b/include/linux/miscdevice.h
--- a/include/linux/miscdevice.h	2021-07-02 14:35:50.428305780 -0300
+++ b/include/linux/miscdevice.h	2021-07-02 16:07:39.072077467 -0300
@@ -21,6 +21,7 @@
 #define APOLLO_MOUSE_MINOR	7	/* unused */
 #define PC110PAD_MINOR		9	/* unused */
 /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
+#define CRYPTODEV_MINOR		70	/*	/dev/crypto	*/
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define APM_MINOR_DEV		134
diff -Nuar a/include/linux/random.h b/include/linux/random.h
--- a/include/linux/random.h	2021-07-02 14:35:50.476306754 -0300
+++ b/include/linux/random.h	2021-07-02 16:18:15.912605685 -0300
@@ -10,6 +10,7 @@
 #include <linux/list.h>
 #include <linux/once.h>
 
+
 #include <uapi/linux/random.h>
 
 struct random_ready_callback {
@@ -34,6 +35,10 @@
 				 unsigned int value) __latent_entropy;
 extern void add_interrupt_randomness(int irq, int irq_flags) __latent_entropy;
 
+extern void random_input_words(__u32 *buf, size_t wordcount, int ent_count);
+extern int random_input_wait(void);
+#define HAS_RANDOM_INPUT_WAIT 1
+
 extern void get_random_bytes(void *buf, int nbytes);
 extern int wait_for_random_bytes(void);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
diff -Nuar a/include/uapi/linux/random.h b/include/uapi/linux/random.h
--- a/include/uapi/linux/random.h	2021-07-02 14:35:51.008317555 -0300
+++ b/include/uapi/linux/random.h	2021-07-02 16:13:10.530163392 -0300
@@ -38,6 +38,31 @@
 /* Reseed CRNG.  (Superuser only.) */
 #define RNDRESEEDCRNG	_IO( 'R', 0x07 )
 
+
+#ifdef CONFIG_FIPS_RNG
+
+/* Size of seed value - equal to AES blocksize */
+#define AES_BLOCK_SIZE_BYTES	16
+#define SEED_SIZE_BYTES			AES_BLOCK_SIZE_BYTES
+/* Size of AES key */
+#define KEY_SIZE_BYTES		16
+
+/* ioctl() structure used by FIPS 140-2 Tests */
+struct rand_fips_test {
+	unsigned char key[KEY_SIZE_BYTES];			/* Input */
+	unsigned char datetime[SEED_SIZE_BYTES];	/* Input */
+	unsigned char seed[SEED_SIZE_BYTES];		/* Input */
+	unsigned char result[SEED_SIZE_BYTES];		/* Output */
+};
+
+/* FIPS 140-2 RNG Variable Seed Test. (Superuser only.) */
+#define RNDFIPSVST	_IOWR('R', 0x10, struct rand_fips_test)
+
+/* FIPS 140-2 RNG Monte Carlo Test. (Superuser only.) */
+#define RNDFIPSMCT	_IOWR('R', 0x11, struct rand_fips_test)
+
+#endif /* #ifdef CONFIG_FIPS_RNG */
+
 struct rand_pool_info {
 	int	entropy_count;
 	int	buf_size;
diff -Nuar a/kernel/pid.c b/kernel/pid.c
--- a/kernel/pid.c	2021-07-02 14:35:51.132320065 -0300
+++ b/kernel/pid.c	2021-07-02 16:31:30.531055533 -0300
@@ -461,6 +461,7 @@
 {
 	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
 }
+EXPORT_SYMBOL(find_task_by_vpid);
 
 struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
 {

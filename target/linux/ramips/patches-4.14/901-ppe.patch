--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -148,12 +148,39 @@
 {
 	int len;
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+typedef struct {
+	uint16_t MAGIC_TAG;
+	uint32_t FOE_Entry:14;
+#if defined (CONFIG_RALINK_MT7620)
+	uint32_t CRSN:5;
+	uint32_t SPORT:3;
+	uint32_t ALG:10;
+#elif defined (CONFIG_RALINK_MT7621)
+	uint32_t CRSN:5;
+	uint32_t SPORT:4;
+	uint32_t ALG:9;
+#else
+	uint32_t FVLD:1;
+	uint32_t ALG:1;
+	uint32_t AI:8;
+	uint32_t SP:3;
+	uint32_t AIS:1;
+	uint32_t RESV2:4;
+#endif
+}  __attribute__ ((packed)) PdmaRxDescInfo4;
+#endif
+
 	len = skb->len - sizeof(struct ipv6hdr);
 	if (len > IPV6_MAXPLEN)
 		len = 0;
 	ipv6_hdr(skb)->payload_len = htons(len);
 	IP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+	if (skb_headroom(skb) >= 6) ((PdmaRxDescInfo4 *)((skb)->head))->CRSN=0x0D;
+#endif
+
 	/* if egress device is enslaved to an L3 master device pass the
 	 * skb to its handler for processing
 	 */
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -2286,6 +2286,10 @@
 			goto err;
 		}
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+		memcpy(ns->head, skb->head, 6); // copy FoE Info
+#endif
+
 		consume_skb(skb);
 		skb = ns;
 		skb_put(skb, len);
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -245,6 +245,11 @@
 
 		fclones->skb2.fclone = SKB_FCLONE_CLONE;
 	}
+
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+	*(uint32_t *)(skb->head) = 0UL;
+#endif
+
 out:
 	return skb;
 nodata:
@@ -1500,6 +1505,11 @@
 	       skb_shinfo(skb),
 	       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+	memcpy(data, skb->head, 6); // copy FoE Info to headroom
+#endif
+
+
 	/*
 	 * if shinfo is shared we must drop the old head gracefully, but if it
 	 * is not we can just drop the old head and let the existing refcount
--- a/net/netfilter/xt_connmark.c
+++ b/net/netfilter/xt_connmark.c
@@ -43,6 +43,29 @@
 	struct nf_conn *ct;
 	u_int32_t newmark;
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+typedef struct {
+	uint16_t MAGIC_TAG;
+	uint32_t FOE_Entry:14;
+#if defined (CONFIG_RALINK_MT7620)
+	uint32_t CRSN:5;
+	uint32_t SPORT:3;
+	uint32_t ALG:10;
+#elif defined (CONFIG_RALINK_MT7621)
+	uint32_t CRSN:5;
+	uint32_t SPORT:4;
+	uint32_t ALG:9;
+#else
+	uint32_t FVLD:1;
+	uint32_t ALG:1;
+	uint32_t AI:8;
+	uint32_t SP:3;
+	uint32_t AIS:1;
+	uint32_t RESV2:4;
+#endif
+}  __attribute__ ((packed)) PdmaRxDescInfo4;
+#endif
+
 	ct = nf_ct_get(skb, &ctinfo);
 	if (ct == NULL)
 		return XT_CONTINUE;
@@ -51,6 +74,14 @@
 	case XT_CONNMARK_SET:
 		newmark = (ct->mark & ~info->ctmask) ^ info->ctmark;
 		if (ct->mark != newmark) {
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+#if !defined(CONFIG_RA_HW_NAT_QDMA)
+			if ((skb_headroom(skb) >= 6) && 
+				!(((PdmaRxDescInfo4 *)((skb)->head))->ALG) && 
+				(((PdmaRxDescInfo4 *)((skb)->head))->MAGIC_TAG == 0x7275)) 
+					((PdmaRxDescInfo4 *)((skb)->head))->ALG=1;
+#endif
+#endif
 			ct->mark = newmark;
 			nf_conntrack_event_cache(IPCT_MARK, ct);
 		}
--- a/net/netfilter/xt_mark.c
+++ b/net/netfilter/xt_mark.c
@@ -29,6 +29,35 @@
 mark_tg(struct sk_buff *skb, const struct xt_action_param *par)
 {
 	const struct xt_mark_tginfo2 *info = par->targinfo;
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+typedef struct {
+	uint16_t MAGIC_TAG;
+	uint32_t FOE_Entry:14;
+#if defined (CONFIG_RALINK_MT7620)
+	uint32_t CRSN:5;
+	uint32_t SPORT:3;
+	uint32_t ALG:10;
+#elif defined (CONFIG_RALINK_MT7621)
+	uint32_t CRSN:5;
+	uint32_t SPORT:4;
+	uint32_t ALG:9;
+#else
+	uint32_t FVLD:1;
+	uint32_t ALG:1;
+	uint32_t AI:8;
+	uint32_t SP:3;
+	uint32_t AIS:1;
+	uint32_t RESV2:4;
+#endif
+}  __attribute__ ((packed)) PdmaRxDescInfo4;
+
+#if !defined(CONFIG_RA_HW_NAT_QDMA)
+			if ((skb_headroom(skb) >= 6) && 
+				!(((PdmaRxDescInfo4 *)((skb)->head))->ALG) && 
+				(((PdmaRxDescInfo4 *)((skb)->head))->MAGIC_TAG == 0x7275)) 
+					((PdmaRxDescInfo4 *)((skb)->head))->ALG=1;
+#endif
+#endif
 
 	skb->mark = (skb->mark & ~info->mask) ^ info->mark;
 	return XT_CONTINUE;
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -57,6 +57,10 @@
 #include <net/netfilter/nf_nat_helper.h>
 #include <net/netns/hash.h>
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+extern int (*ra_sw_nat_hook_tx)(struct sk_buff *skb, int gmac_no);
+#endif
+
 #include "nf_internals.h"
 
 #define NF_CONNTRACK_VERSION	"0.5.0"
@@ -192,6 +196,23 @@
 seqcount_t nf_conntrack_generation __read_mostly;
 static unsigned int nf_conntrack_hash_rnd __read_mostly;
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+static inline bool is_local_svc(u8 protonm)
+{
+	/* Local gre/esp/ah/ip-ip/ipv6_in_ipv4 must be skip from hw/sw offload
+	and mark as interested by ALG  for correct tracking this */
+	switch (protonm) {
+	case IPPROTO_IPIP:
+	case IPPROTO_GRE:
+	case IPPROTO_ESP:
+	case IPPROTO_AH:
+		return true;
+	}
+
+	return false;
+};
+#endif
+
 static u32 hash_conntrack_raw(const struct nf_conntrack_tuple *tuple,
 			      const struct net *net)
 {
@@ -1439,6 +1460,31 @@
 	unsigned int dataoff;
 	u_int8_t protonum;
 	int ret;
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+	struct nf_conn_help *help;
+	int skip_offload = 0;
+
+typedef struct {
+	uint16_t MAGIC_TAG;
+	uint32_t FOE_Entry:14;
+#if defined (CONFIG_RALINK_MT7620)
+	uint32_t CRSN:5;
+	uint32_t SPORT:3;
+	uint32_t ALG:10;
+#elif defined (CONFIG_RALINK_MT7621)
+	uint32_t CRSN:5;
+	uint32_t SPORT:4;
+	uint32_t ALG:9;
+#else
+	uint32_t FVLD:1;
+	uint32_t ALG:1;
+	uint32_t AI:8;
+	uint32_t SP:3;
+	uint32_t AIS:1;
+	uint32_t RESV2:4;
+#endif
+}  __attribute__ ((packed)) PdmaRxDescInfo4;
+#endif
 
 	tmpl = nf_ct_get(skb, &ctinfo);
 	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@ -1521,6 +1567,42 @@
 		goto out;
 	}
 
+#if IS_ENABLED(CONFIG_RA_HW_NAT)
+	if (hooknum == NF_INET_LOCAL_OUT || ((PdmaRxDescInfo4 *)((skb)->head))->ALG)
+		goto skip_alg_mark;
+
+	/*
+	* skip ALG marked packets from all fastpaths
+	*/
+	help = nfct_help(ct);
+	if (help && help->helper) {
+		skip_offload = 1;
+		goto skip_pkt_check;
+	}
+
+#ifdef CONFIG_XFRM
+	if (skb_sec_path(skb)) {
+		skip_offload = 1;
+		goto skip_pkt_check;
+	}
+#endif
+
+	/* this code section may be used for skip some types traffic,
+	only if hardware nat support enabled or software fastnat support enabled */
+	if (ra_sw_nat_hook_tx != NULL) {
+	}
+
+skip_pkt_check:
+	/* skip several proto only from hw_nat */
+	if (skip_offload || (pf == PF_INET && is_local_svc(protonum)))
+		if ((skb_headroom(skb) >= 6) && 
+			!(((PdmaRxDescInfo4 *)((skb)->head))->ALG) && 
+			(((PdmaRxDescInfo4 *)((skb)->head))->MAGIC_TAG == 0x7275)) 
+				((PdmaRxDescInfo4 *)((skb)->head))->ALG=1;
+
+skip_alg_mark:
+#endif
+
 	if (ctinfo == IP_CT_ESTABLISHED_REPLY &&
 	    !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
 		nf_conntrack_event_cache(IPCT_REPLY, ct);
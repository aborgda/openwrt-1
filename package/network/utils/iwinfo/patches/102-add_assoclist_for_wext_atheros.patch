--- a/iwinfo_wext.c	2021-12-22 19:58:31.220108040 -0300
+++ b/iwinfo_wext.c	2022-01-04 11:48:57.941653109 -0300
@@ -22,6 +22,107 @@
 #include "iwinfo.h"
 #include "iwinfo_wext.h"
 
+#define WEXT_ATHEROS_SUPPORT
+
+
+#ifdef WEXT_ATHEROS_SUPPORT
+
+// Copy-pasted from ieee80211.h
+
+struct ieee80211req_sta_info {
+        u_int16_t       isi_len;                /* length (mult of 4) */
+        u_int16_t       isi_freq;               /* MHz */
+        u_int32_t       awake_time;             /* time is active mode */
+        u_int32_t       ps_time;                /* time in power save mode */
+        u_int32_t       isi_flags;      		/* channel flags */
+        u_int16_t       isi_state;              /* state flags */
+        u_int8_t        isi_authmode;           /* authentication algorithm */
+        int8_t          isi_rssi;
+        int8_t          isi_min_rssi;
+        int8_t          isi_max_rssi;
+        u_int16_t       isi_capinfo;            /* capabilities */
+        u_int8_t        isi_athflags;           /* Atheros capabilities */
+        u_int8_t        isi_erp;                /* ERP element */
+        u_int8_t        isi_ps;                 /* psmode */
+        u_int8_t        isi_macaddr[6];
+        u_int8_t        isi_nrates;
+                                                /* negotiated rates */
+        u_int8_t        isi_rates[44];
+        u_int8_t        isi_txrate;             /* index to isi_rates[] */
+        u_int32_t       isi_txratekbps;         /* tx rate in Kbps, for 11n */
+        u_int16_t       isi_ie_len;             /* IE length */
+        u_int16_t       isi_associd;            /* assoc response */
+        u_int16_t       isi_txpower;            /* current tx power */
+        u_int16_t       isi_vlan;               /* vlan tag */
+        u_int16_t       isi_txseqs[17];         /* seq to be transmitted */
+        u_int16_t       isi_rxseqs[17];         /* seq previous for qos frames*/
+        u_int16_t       isi_inact;              /* inactivity timer */
+        u_int8_t        isi_uapsd;              /* UAPSD queues */
+        u_int8_t        isi_opmode;             /* sta operating mode */
+        u_int8_t        isi_cipher;
+        u_int32_t       isi_assoc_time;         /* sta association time */
+        struct timespec isi_tr069_assoc_time;   /* sta association time in timespec format */
+
+
+        u_int16_t   isi_htcap;      /* HT capabilities */
+        u_int32_t   isi_rxratekbps; /* rx rate in Kbps */
+                                	/* We use this as a common variable for legacy rates
+                                   	and lln. We do not attempt to make it symmetrical
+                                   	to isi_txratekbps and isi_txrate, which seem to be
+                                   	separate due to legacy code. */
+        /* XXX frag state? */
+        /* variable length IE data */
+        u_int8_t isi_maxrate_per_client; 	/* Max rate per client */
+        u_int16_t   isi_stamode;  			/* Wireless mode for connected sta */
+        u_int32_t isi_ext_cap;    			/* Extended capabilities */
+        u_int8_t isi_nss;         			/* number of tx and rx chains */
+        u_int8_t isi_is_256qam;   			/* 256 QAM support */
+        u_int8_t isi_operating_bands : 2; 	/* Operating bands */
+        u_int8_t  isi_chwidth;            	/* communication band width */
+        u_int32_t isi_vhtcap;             	/* VHT capabilities */
+        u_int8_t isi_rx_nss;         		/* number of rx chains */
+        u_int8_t isi_tx_nss;         		/* number of tx chains */
+        u_int8_t isi_tx_rate_mcs;
+        u_int8_t isi_tx_rate_flags;
+};
+
+#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
+
+#define	IEEE80211_RATE_VAL    			0x7f
+#define	IEEE80211_CWM_WIDTH20 			0
+#define	IEEE80211_CWM_WIDTH40 			1
+#define	IEEE80211_CWM_WIDTH80 			2
+#define IEEE80211_MODE_AUTO             0
+#define IEEE80211_MODE_11A              1
+#define IEEE80211_MODE_11B              2
+#define IEEE80211_MODE_11G              3
+#define IEEE80211_MODE_FH               4
+#define IEEE80211_MODE_TURBO_A          5
+#define IEEE80211_MODE_TURBO_G          6
+#define IEEE80211_MODE_11NA_HT20        7
+#define IEEE80211_MODE_11NG_HT20        8
+#define IEEE80211_MODE_11NA_HT40PLUS    9
+#define IEEE80211_MODE_11NA_HT40MINUS   10
+#define IEEE80211_MODE_11NG_HT40PLUS    11
+#define IEEE80211_MODE_11NG_HT40MINUS   12
+#define IEEE80211_MODE_11NG_HT40        13
+#define IEEE80211_MODE_11NA_HT40        14
+#define IEEE80211_MODE_11AC_VHT20       15
+#define IEEE80211_MODE_11AC_VHT40PLUS   16
+#define IEEE80211_MODE_11AC_VHT40MINUS  17
+#define IEEE80211_MODE_11AC_VHT40       18
+#define IEEE80211_MODE_11AC_VHT80       19
+#define IEEE80211_HTCAP_C_SHORTGI20  	0x0020
+#define IEEE80211_HTCAP_C_SHORTGI40  	0x0040
+#define IEEE80211_VHTCAP_SHORTGI_80  	0x00000020 /* B5 Short GI for 80MHz */
+#define IEEE80211_VHTCAP_SHORTGI_160 	0x00000040 /* B6 Short GI for 160 and 80+80 MHz */
+
+#define MODE_IS_20MHZ(m) ((m==IEEE80211_MODE_11NA_HT20)||(m==IEEE80211_MODE_11NG_HT20)||(m==IEEE80211_MODE_11AC_VHT20))
+#define MODE_IS_40MHZ(m) (((m>=IEEE80211_MODE_11NA_HT40PLUS) && (m<= IEEE80211_MODE_11NA_HT40))||((m>=IEEE80211_MODE_11AC_VHT40PLUS) && (m<=IEEE80211_MODE_11AC_VHT40)))
+#define MODE_IS_80MHZ(m) (m==IEEE80211_MODE_11AC_VHT80)
+
+#endif
+
 static double wext_freq2float(const struct iw_freq *in)
 {
 	int		i;
@@ -318,10 +419,166 @@
 	return -1;
 }
 
-static int wext_get_assoclist(const char *ifname, char *buf, int *len)
+
+static int wext_get_assoclist(const char *ifname, char *wext_buf, int *wext_len )
 {
-	/* Stub */
+
+#ifdef WEXT_ATHEROS_SUPPORT
+    uint8_t *buf;
+    struct iwreq iwr;
+    int s;
+    u_int32_t txrate, rxrate = 0, maxrate = 0 , entry_count ;
+    u_int32_t time_val=0, hour_val=0, min_val=0, sec_val=0 , entry_index;
+    const char *ntoa = NULL;
+    int req_space = 0;
+    u_int64_t len = 0;
+	*wext_len = 0;
+
+	buf = malloc(24*1024);
+	if(!buf) {
+	  fprintf (stderr, "Unable to allocate memory for station list\n");
+	  return -1;
+	}
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0){
+		free(buf);
+		return -1;
+	}
+
+	(void) memset(&iwr, 0, sizeof(iwr));
+	if (strlcpy(iwr.ifr_name, ifname, sizeof(iwr.ifr_name)) >= sizeof(iwr.ifr_name)) {
+		fprintf(stderr, "ifname too long: %s\n", ifname); close(s);
+		free(buf);
+		return -1;
+	}
+
+	iwr.u.data.pointer = (void *) buf;
+	iwr.u.data.length = 24*1024;
+    iwr.u.data.flags = 0;
+    
+
+    req_space = ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr);
+	if (req_space < 0 ){
+		free(buf);
+		return -1;
+    }
+    else if(req_space > 0) {
+        free(buf);
+        buf = malloc(req_space);
+        if(!buf) {
+            fprintf (stderr, "Unable to allocate memory for station list\n");
+            return -1;
+        }
+        iwr.u.data.pointer = (void *) buf;
+        iwr.u.data.length = req_space;
+        if(iwr.u.data.length < req_space)
+            iwr.u.data.flags = 1;
+        if (ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr) < 0 ){
+            free(buf);
+            fprintf(stderr, "unable to get station information");
+			return -1;
+        }
+        len = req_space;
+    }
+    else {
+        len = iwr.u.data.length;
+    }
+
+
+	uint64_t buff_index = 0;
+	entry_count = 0;
+	while( buff_index + sizeof(struct ieee80211req_sta_info) <= len ){
+		struct ieee80211req_sta_info *ieee80211_entry;
+		
+		ieee80211_entry = (struct ieee80211req_sta_info*)(buf + buff_index);
+		
+		entry_count++;
+		buff_index += ieee80211_entry->isi_len;
+	}
+	
+	*wext_len = entry_count * sizeof(struct iwinfo_assoclist_entry);
+	
+	
+   	for( entry_index = 0 ; entry_index < entry_count ; entry_index ++ )
+	{
+		struct ieee80211req_sta_info *ieee80211_entry;
+		struct iwinfo_assoclist_entry* iwinfo_entry;
+		
+		ieee80211_entry = (struct ieee80211req_sta_info *) buf;
+		iwinfo_entry = (struct iwinfo_assoclist_entry*) wext_buf;
+		iwinfo_entry += entry_index;
+
+		memset( iwinfo_entry , 0 , sizeof(struct iwinfo_assoclist_entry) );
+
+		// Filling fields		
+		memcpy( iwinfo_entry->mac , ieee80211_entry->isi_macaddr , 6 );
+
+
+		iwinfo_entry->signal 			= ieee80211_entry->isi_txpower;
+		//iwinfo_entry->signal_avg		=;
+		//iwinfo_entry->noise				=;
+		iwinfo_entry->inactive 			= ieee80211_entry->isi_inact;
+		iwinfo_entry->connected_time	= ieee80211_entry->isi_tr069_assoc_time.tv_sec * 1000;
+		iwinfo_entry->rx_packets		= ieee80211_entry->isi_txseqs[0];
+		iwinfo_entry->tx_packets		= ieee80211_entry->isi_rxseqs[0];
+		// iwinfo_entry->rx_drop_misc		=;
+		
+		// iwinfo_entry->rx_rate.rate 		= ;
+		// iwinfo_entry->rx_rate.mcs 		= ;
+		// iwinfo_entry->rx_rate.is_40mhz 	= ;
+		// iwinfo_entry->rx_rate.is_short_gi = ;
+		// iwinfo_entry->rx_rate.is_ht 	= ;
+		// iwinfo_entry->rx_rate.is_vht 	= ;
+		// iwinfo_entry->rx_rate.mhz 		= ;
+		// iwinfo_entry->rx_rate.nss 		= ;
+
+		int stamode = ieee80211_entry->isi_stamode;
+
+		iwinfo_entry->tx_rate.rate 		= 1000*(ieee80211_entry->isi_rates[ieee80211_entry->isi_txrate] & IEEE80211_RATE_VAL)/2;
+		iwinfo_entry->tx_rate.mcs 		= ieee80211_entry->isi_tx_rate_mcs;
+		iwinfo_entry->tx_rate.is_40mhz 	= ieee80211_entry->isi_chwidth==IEEE80211_CWM_WIDTH40;
+		//iwinfo_entry->tx_rate.is_short_gi = ;
+		iwinfo_entry->tx_rate.is_ht 	= 	(stamode >= IEEE80211_MODE_11NA_HT20 )  || (stamode <= IEEE80211_MODE_11NA_HT40 );
+		iwinfo_entry->tx_rate.is_vht 	= 	(stamode >= IEEE80211_MODE_11AC_VHT20 ) || ( stamode<= IEEE80211_MODE_11AC_VHT80 );
+		iwinfo_entry->tx_rate.mhz 		= 20*MODE_IS_20MHZ(stamode) + 40*MODE_IS_40MHZ(stamode) + 80*MODE_IS_80MHZ(stamode);
+		//iwinfo_entry->tx_rate.nss 		= ;
+		
+		//iwinfo_entry->rx_bytes			=;
+		//iwinfo_entry->tx_bytes			=;
+		//iwinfo_entry->tx_retries		= ;
+		//iwinfo_entry->tx_failed			=;
+		//iwinfo_entry->t_offset			=;
+		iwinfo_entry->is_authorized 	= 1;
+		iwinfo_entry->is_authenticated 	= 1;
+		//iwinfo_entry->is_preamble_short	=;
+		//iwinfo_entry->is_wme			=;
+		//iwinfo_entry->is_mfp			=;
+		//iwinfo_entry->is_tdls			=;
+		//iwinfo_entry->thr				=;
+		//iwinfo_entry->llid				=;
+		//iwinfo_entry->plid				=;
+		
+		// iwinfo_entry->plink_state;
+		// iwinfo_entry->local_ps;
+		// iwinfo_entry->peer_ps;
+		// iwinfo_entry->nonpeer_ps;
+
+		buf += ieee80211_entry->isi_len;
+
+	}
+
+	if( entry_count > 0 ){
+
+	}
+
+
+	free(buf);
+	return 0;
+#else
 	return -1;
+#endif
+
 }
 
 static int wext_get_txpwrlist(const char *ifname, char *buf, int *len)

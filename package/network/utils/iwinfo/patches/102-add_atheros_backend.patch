diff -Nuar temp_old/api/ath.h temp_new/api/ath.h
--- temp_old/api/ath.h	1969-12-31 21:00:00.000000000 -0300
+++ temp_new/api/ath.h	2022-01-24 10:58:10.334346258 -0300
@@ -0,0 +1,99 @@
+#ifndef _ATH_H_
+#define _ATH_H_
+
+// Copy-pasted from ieee80211.h
+
+struct ieee80211req_sta_info {
+        u_int16_t       isi_len;                /* length (mult of 4) */
+        u_int16_t       isi_freq;               /* MHz */
+        u_int32_t       awake_time;             /* time is active mode */
+        u_int32_t       ps_time;                /* time in power save mode */
+        u_int32_t       isi_flags;      		/* channel flags */
+        u_int16_t       isi_state;              /* state flags */
+        u_int8_t        isi_authmode;           /* authentication algorithm */
+        int8_t          isi_rssi;
+        int8_t          isi_min_rssi;
+        int8_t          isi_max_rssi;
+        u_int16_t       isi_capinfo;            /* capabilities */
+        u_int8_t        isi_athflags;           /* Atheros capabilities */
+        u_int8_t        isi_erp;                /* ERP element */
+        u_int8_t        isi_ps;                 /* psmode */
+        u_int8_t        isi_macaddr[6];
+        u_int8_t        isi_nrates;
+                                                /* negotiated rates */
+        u_int8_t        isi_rates[44];
+        u_int8_t        isi_txrate;             /* index to isi_rates[] */
+        u_int32_t       isi_txratekbps;         /* tx rate in Kbps, for 11n */
+        u_int16_t       isi_ie_len;             /* IE length */
+        u_int16_t       isi_associd;            /* assoc response */
+        u_int16_t       isi_txpower;            /* current tx power */
+        u_int16_t       isi_vlan;               /* vlan tag */
+        u_int16_t       isi_txseqs[17];         /* seq to be transmitted */
+        u_int16_t       isi_rxseqs[17];         /* seq previous for qos frames*/
+        u_int16_t       isi_inact;              /* inactivity timer */
+        u_int8_t        isi_uapsd;              /* UAPSD queues */
+        u_int8_t        isi_opmode;             /* sta operating mode */
+        u_int8_t        isi_cipher;
+        u_int32_t       isi_assoc_time;         /* sta association time */
+        struct timespec isi_tr069_assoc_time;   /* sta association time in timespec format */
+
+
+        u_int16_t   isi_htcap;      /* HT capabilities */
+        u_int32_t   isi_rxratekbps; /* rx rate in Kbps */
+                                	/* We use this as a common variable for legacy rates
+                                   	and lln. We do not attempt to make it symmetrical
+                                   	to isi_txratekbps and isi_txrate, which seem to be
+                                   	separate due to legacy code. */
+        /* XXX frag state? */
+        /* variable length IE data */
+        u_int8_t isi_maxrate_per_client; 	/* Max rate per client */
+        u_int16_t   isi_stamode;  			/* Wireless mode for connected sta */
+        u_int32_t isi_ext_cap;    			/* Extended capabilities */
+        u_int8_t isi_nss;         			/* number of tx and rx chains */
+        u_int8_t isi_is_256qam;   			/* 256 QAM support */
+        u_int8_t isi_operating_bands : 2; 	/* Operating bands */
+        u_int8_t  isi_chwidth;            	/* communication band width */
+        u_int32_t isi_vhtcap;             	/* VHT capabilities */
+        u_int8_t isi_rx_nss;         		/* number of rx chains */
+        u_int8_t isi_tx_nss;         		/* number of tx chains */
+        u_int8_t isi_tx_rate_mcs;
+        u_int8_t isi_tx_rate_flags;
+};
+
+#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
+
+#define	IEEE80211_RATE_VAL    			0x7f
+#define	IEEE80211_CWM_WIDTH20 			0
+#define	IEEE80211_CWM_WIDTH40 			1
+#define	IEEE80211_CWM_WIDTH80 			2
+#define IEEE80211_MODE_AUTO             0
+#define IEEE80211_MODE_11A              1
+#define IEEE80211_MODE_11B              2
+#define IEEE80211_MODE_11G              3
+#define IEEE80211_MODE_FH               4
+#define IEEE80211_MODE_TURBO_A          5
+#define IEEE80211_MODE_TURBO_G          6
+#define IEEE80211_MODE_11NA_HT20        7
+#define IEEE80211_MODE_11NG_HT20        8
+#define IEEE80211_MODE_11NA_HT40PLUS    9
+#define IEEE80211_MODE_11NA_HT40MINUS   10
+#define IEEE80211_MODE_11NG_HT40PLUS    11
+#define IEEE80211_MODE_11NG_HT40MINUS   12
+#define IEEE80211_MODE_11NG_HT40        13
+#define IEEE80211_MODE_11NA_HT40        14
+#define IEEE80211_MODE_11AC_VHT20       15
+#define IEEE80211_MODE_11AC_VHT40PLUS   16
+#define IEEE80211_MODE_11AC_VHT40MINUS  17
+#define IEEE80211_MODE_11AC_VHT40       18
+#define IEEE80211_MODE_11AC_VHT80       19
+#define IEEE80211_HTCAP_C_SHORTGI20  	0x0020
+#define IEEE80211_HTCAP_C_SHORTGI40  	0x0040
+#define IEEE80211_VHTCAP_SHORTGI_80  	0x00000020 /* B5 Short GI for 80MHz */
+#define IEEE80211_VHTCAP_SHORTGI_160 	0x00000040 /* B6 Short GI for 160 and 80+80 MHz */
+
+#define MODE_IS_20MHZ(m) ((m==IEEE80211_MODE_11NA_HT20)||(m==IEEE80211_MODE_11NG_HT20)||(m==IEEE80211_MODE_11AC_VHT20))
+#define MODE_IS_40MHZ(m) (((m>=IEEE80211_MODE_11NA_HT40PLUS) && (m<= IEEE80211_MODE_11NA_HT40))||((m>=IEEE80211_MODE_11AC_VHT40PLUS) && (m<=IEEE80211_MODE_11AC_VHT40)))
+#define MODE_IS_80MHZ(m) (m==IEEE80211_MODE_11AC_VHT80)
+
+
+#endif // _ATH_H_
diff -Nuar temp_old/include/iwinfo.h temp_new/include/iwinfo.h
--- temp_old/include/iwinfo.h	2022-01-24 10:58:10.338346131 -0300
+++ temp_new/include/iwinfo.h	2022-01-24 10:58:10.338346131 -0300
@@ -297,6 +297,7 @@
 extern const struct iwinfo_ops nl80211_ops;
 extern const struct iwinfo_ops wl_ops;
 extern const struct iwinfo_ops ramips_ops;
+extern const struct iwinfo_ops iwath_ops;
 
 #include "iwinfo/utils.h"
 
diff -Nuar temp_old/iwinfo_ath.c temp_new/iwinfo_ath.c
--- temp_old/iwinfo_ath.c	1969-12-31 21:00:00.000000000 -0300
+++ temp_new/iwinfo_ath.c	2022-01-24 10:58:10.330346385 -0300
@@ -0,0 +1,727 @@
+/*
+ * iwinfo - Wireless Information Library - Linux Wireless Extension Backend
+ *
+ *   Copyright (C) 2009 Jo-Philipp Wich <xm@subsignal.org>
+ *
+ * The iwinfo library is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * The iwinfo library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the iwinfo library. If not, see http://www.gnu.org/licenses/.
+ *
+ * Parts of this code are derived from the Linux wireless tools, iwlib.c,
+ * iwlist.c and iwconfig.c in particular.
+ */
+
+#include "iwinfo.h"
+#include "iwinfo_wext.h"
+#include "api/ath.h"
+
+static double iwath_freq2float(const struct iw_freq *in)
+{
+	int		i;
+	double	res = (double) in->m;
+	for(i = 0; i < in->e; i++) res *= 10;
+	return res;
+}
+
+static inline int iwath_freq2mhz(const struct iw_freq *in)
+{
+	if( in->e == 6 )
+	{
+		return in->m;
+	}
+	else
+	{
+		return (int)(iwath_freq2float(in) / 1000000);
+	}
+}
+
+static inline int iwath_ioctl(const char *ifname, int cmd, struct iwreq *wrq)
+{
+	if( !strncmp(ifname, "mon.", 4) )
+		strncpy(wrq->ifr_name, &ifname[4], IFNAMSIZ);
+	else
+		strncpy(wrq->ifr_name, ifname, IFNAMSIZ);
+
+	return iwinfo_ioctl(cmd, wrq);
+}
+
+
+static int iwath_probe(const char *ifname)
+{
+	struct iwreq wrq;
+
+	if((iwath_ioctl(ifname, SIOCGIWNAME, &wrq) >= 0) && strncmp(wrq.u.name,"IEEE 802.11",10)==0 )
+		return 1;
+
+	return 0;
+}
+
+static void iwath_close(void)
+{
+	/* Nop */
+}
+
+static int iwath_get_mode(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if(iwath_ioctl(ifname, SIOCGIWMODE, &wrq) >= 0)
+	{
+		switch(wrq.u.mode)
+		{
+			case 1:
+				*buf = IWINFO_OPMODE_ADHOC;
+				break;
+
+			case 2:
+				*buf = IWINFO_OPMODE_CLIENT;
+				break;
+
+			case 3:
+				*buf = IWINFO_OPMODE_MASTER;
+				break;
+
+			case 6:
+				*buf = IWINFO_OPMODE_MONITOR;
+				break;
+
+			default:
+				*buf = IWINFO_OPMODE_UNKNOWN;
+				break;
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_ssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	wrq.u.essid.pointer = (caddr_t) buf;
+	wrq.u.essid.length  = IW_ESSID_MAX_SIZE + 1;
+	wrq.u.essid.flags   = 0;
+
+	if(iwath_ioctl(ifname, SIOCGIWESSID, &wrq) >= 0)
+		return 0;
+
+	return -1;
+}
+
+static int iwath_get_bssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	if(iwath_ioctl(ifname, SIOCGIWAP, &wrq) >= 0)
+	{
+		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
+			(uint8_t)wrq.u.ap_addr.sa_data[0], (uint8_t)wrq.u.ap_addr.sa_data[1],
+			(uint8_t)wrq.u.ap_addr.sa_data[2], (uint8_t)wrq.u.ap_addr.sa_data[3],
+			(uint8_t)wrq.u.ap_addr.sa_data[4], (uint8_t)wrq.u.ap_addr.sa_data[5]);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_bitrate(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if(iwath_ioctl(ifname, SIOCGIWRATE, &wrq) >= 0)
+	{
+		*buf = (wrq.u.bitrate.value / 1000);
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_channel(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+	double freq;
+	int i;
+
+	if(iwath_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		if( wrq.u.freq.m >= 1000 )
+		{
+			freq = iwath_freq2float(&wrq.u.freq);
+			wrq.u.data.pointer = (caddr_t) &range;
+			wrq.u.data.length  = sizeof(struct iw_range);
+			wrq.u.data.flags   = 0;
+
+			if(iwath_ioctl(ifname, SIOCGIWRANGE, &wrq) >= 0)
+			{
+				for(i = 0; i < range.num_frequency; i++)
+				{
+					if( iwath_freq2float(&range.freq[i]) == freq )
+					{
+						*buf = range.freq[i].i;
+						return 0;
+					}
+				}
+			}
+		}
+		else
+		{
+			*buf = wrq.u.freq.m;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int iwath_get_center_chan1(const char *ifname, int *buf)
+{
+	/* Not Supported */
+	return -1;
+}
+
+static int iwath_get_center_chan2(const char *ifname, int *buf)
+{
+	/* Not Supported */
+	return -1;
+}
+
+static int iwath_get_frequency(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+	int i, channel;
+
+	if(iwath_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		/* We got a channel number instead ... */
+		if( wrq.u.freq.m < 1000 )
+		{
+			channel = wrq.u.freq.m;
+			wrq.u.data.pointer = (caddr_t) &range;
+			wrq.u.data.length  = sizeof(struct iw_range);
+			wrq.u.data.flags   = 0;
+
+			if(iwath_ioctl(ifname, SIOCGIWRANGE, &wrq) >= 0)
+			{
+				for(i = 0; i < range.num_frequency; i++)
+				{
+					if( range.freq[i].i == channel )
+					{
+						*buf = iwath_freq2mhz(&range.freq[i]);
+						return 0;
+					}
+				}
+			}
+		}
+		else
+		{
+			*buf = iwath_freq2mhz(&wrq.u.freq);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int iwath_get_txpower(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	wrq.u.txpower.flags = 0;
+
+	if(iwath_ioctl(ifname, SIOCGIWTXPOW, &wrq) >= 0)
+	{
+		if(wrq.u.txpower.flags & IW_TXPOW_MWATT)
+			*buf = iwinfo_mw2dbm(wrq.u.txpower.value);
+		else
+			*buf = wrq.u.txpower.value;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_signal(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_statistics stats;
+
+	wrq.u.data.pointer = (caddr_t) &stats;
+	wrq.u.data.length  = sizeof(struct iw_statistics);
+	wrq.u.data.flags   = 1;
+
+	if(iwath_ioctl(ifname, SIOCGIWSTATS, &wrq) >= 0)
+	{
+		*buf = (stats.qual.updated & IW_QUAL_DBM)
+			? (stats.qual.level - 0x100) : stats.qual.level;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_noise(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_statistics stats;
+
+	wrq.u.data.pointer = (caddr_t) &stats;
+	wrq.u.data.length  = sizeof(struct iw_statistics);
+	wrq.u.data.flags   = 1;
+
+	if(iwath_ioctl(ifname, SIOCGIWSTATS, &wrq) >= 0)
+	{
+		*buf = (stats.qual.updated & IW_QUAL_DBM)
+			? (stats.qual.noise - 0x100) : stats.qual.noise;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_quality(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_statistics stats;
+
+	wrq.u.data.pointer = (caddr_t) &stats;
+	wrq.u.data.length  = sizeof(struct iw_statistics);
+	wrq.u.data.flags   = 1;
+
+	if(iwath_ioctl(ifname, SIOCGIWSTATS, &wrq) >= 0)
+	{
+		*buf = stats.qual.qual;
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_quality_max(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+
+	wrq.u.data.pointer = (caddr_t) &range;
+	wrq.u.data.length  = sizeof(struct iw_range);
+	wrq.u.data.flags   = 0;
+
+	if(iwath_ioctl(ifname, SIOCGIWRANGE, &wrq) >= 0)
+	{
+		*buf = range.max_qual.qual;
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_assoclist(const char *ifname, char *iwath_buf, int *iwath_len )
+{
+	uint8_t *buf;
+    struct iwreq iwr;
+    int s;
+    u_int32_t txrate, rxrate = 0, maxrate = 0 , entry_count ;
+    u_int32_t time_val=0, hour_val=0, min_val=0, sec_val=0 , entry_index;
+    const char *ntoa = NULL;
+    int req_space = 0;
+    u_int64_t len = 0;
+	*iwath_len = 0;
+
+	buf = malloc(24*1024);
+	if(!buf) {
+	  fprintf (stderr, "Unable to allocate memory for station list\n");
+	  return -1;
+	}
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0){
+		free(buf);
+		return -1;
+	}
+
+	(void) memset(&iwr, 0, sizeof(iwr));
+	if (strlcpy(iwr.ifr_name, ifname, sizeof(iwr.ifr_name)) >= sizeof(iwr.ifr_name)) {
+		fprintf(stderr, "ifname too long: %s\n", ifname); close(s);
+		free(buf);
+		return -1;
+	}
+
+	iwr.u.data.pointer = (void *) buf;
+	iwr.u.data.length = 24*1024;
+    iwr.u.data.flags = 0;
+    
+
+    req_space = ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr);
+	if (req_space < 0 ){
+		free(buf);
+		return -1;
+    }
+    else if(req_space > 0) {
+        free(buf);
+        buf = malloc(req_space);
+        if(!buf) {
+            fprintf (stderr, "Unable to allocate memory for station list\n");
+            return -1;
+        }
+        iwr.u.data.pointer = (void *) buf;
+        iwr.u.data.length = req_space;
+        if(iwr.u.data.length < req_space)
+            iwr.u.data.flags = 1;
+        if (ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr) < 0 ){
+            free(buf);
+            fprintf(stderr, "unable to get station information");
+			return -1;
+        }
+        len = req_space;
+    }
+    else {
+        len = iwr.u.data.length;
+    }
+
+
+	uint64_t buff_index = 0;
+	entry_count = 0;
+	while( buff_index + sizeof(struct ieee80211req_sta_info) <= len ){
+		struct ieee80211req_sta_info *ieee80211_entry;
+		
+		ieee80211_entry = (struct ieee80211req_sta_info*)(buf + buff_index);
+		
+		entry_count++;
+		buff_index += ieee80211_entry->isi_len;
+	}
+	
+	*iwath_len = entry_count * sizeof(struct iwinfo_assoclist_entry);
+	
+	
+   	for( entry_index = 0 ; entry_index < entry_count ; entry_index ++ )
+	{
+		struct ieee80211req_sta_info *ieee80211_entry;
+		struct iwinfo_assoclist_entry* iwinfo_entry;
+		
+		ieee80211_entry = (struct ieee80211req_sta_info *) buf;
+		iwinfo_entry = (struct iwinfo_assoclist_entry*) iwath_buf;
+		iwinfo_entry += entry_index;
+
+		memset( iwinfo_entry , 0 , sizeof(struct iwinfo_assoclist_entry) );
+
+		// Filling fields		
+		memcpy( iwinfo_entry->mac , ieee80211_entry->isi_macaddr , 6 );
+
+
+		iwinfo_entry->signal 			= ieee80211_entry->isi_rssi - 77;
+		//iwinfo_entry->signal_avg		=;
+		iwinfo_entry->noise				= -95;
+		iwinfo_entry->inactive 			= ieee80211_entry->isi_inact;
+		iwinfo_entry->connected_time	= ieee80211_entry->isi_tr069_assoc_time.tv_sec * 1000;
+		iwinfo_entry->rx_packets		= ieee80211_entry->isi_txseqs[0];
+		iwinfo_entry->tx_packets		= ieee80211_entry->isi_rxseqs[0];
+		// iwinfo_entry->rx_drop_misc		=;
+		
+		iwinfo_entry->rx_rate.rate 		= ieee80211_entry->isi_rxratekbps;
+		// iwinfo_entry->rx_rate.mcs 		= ;
+		// iwinfo_entry->rx_rate.is_40mhz 	= ;
+		// iwinfo_entry->rx_rate.is_short_gi = ;
+		// iwinfo_entry->rx_rate.is_ht 	= ;
+		// iwinfo_entry->rx_rate.is_vht 	= ;
+		// iwinfo_entry->rx_rate.mhz 		= ;
+		// iwinfo_entry->rx_rate.nss 		= ;
+
+		int stamode = ieee80211_entry->isi_stamode;
+
+		iwinfo_entry->tx_rate.rate 		= ieee80211_entry->isi_txratekbps;
+		iwinfo_entry->tx_rate.mcs 		= ieee80211_entry->isi_tx_rate_mcs;
+		iwinfo_entry->tx_rate.is_40mhz 	= ieee80211_entry->isi_chwidth==IEEE80211_CWM_WIDTH40;
+		//iwinfo_entry->tx_rate.is_short_gi = ;
+		iwinfo_entry->tx_rate.is_ht 	= 	(stamode >= IEEE80211_MODE_11NA_HT20 )  || (stamode <= IEEE80211_MODE_11NA_HT40 );
+		iwinfo_entry->tx_rate.is_vht 	= 	(stamode >= IEEE80211_MODE_11AC_VHT20 ) || ( stamode<= IEEE80211_MODE_11AC_VHT80 );
+		iwinfo_entry->tx_rate.mhz 		= 20*MODE_IS_20MHZ(stamode) + 40*MODE_IS_40MHZ(stamode) + 80*MODE_IS_80MHZ(stamode);
+		//iwinfo_entry->tx_rate.nss 		= ;
+		
+		//iwinfo_entry->rx_bytes			=;
+		//iwinfo_entry->tx_bytes			=;
+		//iwinfo_entry->tx_retries		= ;
+		//iwinfo_entry->tx_failed			=;
+		//iwinfo_entry->t_offset			=;
+		iwinfo_entry->is_authorized 	= 1;
+		iwinfo_entry->is_authenticated 	= 1;
+		//iwinfo_entry->is_preamble_short	=;
+		//iwinfo_entry->is_wme			=;
+		//iwinfo_entry->is_mfp			=;
+		//iwinfo_entry->is_tdls			=;
+		//iwinfo_entry->thr				=;
+		//iwinfo_entry->llid				=;
+		//iwinfo_entry->plid				=;
+		
+		// iwinfo_entry->plink_state;
+		// iwinfo_entry->local_ps;
+		// iwinfo_entry->peer_ps;
+		// iwinfo_entry->nonpeer_ps;
+
+		buf += ieee80211_entry->isi_len;
+
+	}
+
+	if( entry_count > 0 ){
+
+	}
+
+
+	free(buf);
+	return 0;
+}
+
+static int iwath_get_txpwrlist(const char *ifname, char *buf, int *len)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+	struct iwinfo_txpwrlist_entry entry;
+	int i;
+
+	wrq.u.data.pointer = (caddr_t) &range;
+	wrq.u.data.length  = sizeof(struct iw_range);
+	wrq.u.data.flags   = 0;
+
+	if( (iwath_ioctl(ifname, SIOCGIWRANGE, &wrq) >= 0) &&
+	    (range.num_txpower > 0) && (range.num_txpower <= IW_MAX_TXPOWER) &&
+	    !(range.txpower_capa & IW_TXPOW_RELATIVE)
+	) {
+		for( i = 0; i < range.num_txpower; i++ )
+		{
+			if( range.txpower_capa & IW_TXPOW_MWATT )
+			{
+				entry.dbm = iwinfo_mw2dbm(range.txpower[i]);
+				entry.mw  = range.txpower[i];
+			}
+
+			/* Madwifi does neither set mW not dBm caps, also iwlist assumes
+			 * dBm if mW is not set, so don't check here... */
+			else /* if( range.txpower_capa & IW_TXPOW_DBM ) */
+			{
+				entry.dbm = range.txpower[i];
+				entry.mw  = iwinfo_dbm2mw(range.txpower[i]);
+			}
+
+			memcpy(&buf[i*sizeof(entry)], &entry, sizeof(entry));
+		}
+
+		*len = i * sizeof(entry);
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_freqlist(const char *ifname, char *buf, int *len)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+	struct iwinfo_freqlist_entry entry;
+	int i, bl;
+
+	wrq.u.data.pointer = (caddr_t) &range;
+	wrq.u.data.length  = sizeof(struct iw_range);
+	wrq.u.data.flags   = 0;
+
+	if(iwath_ioctl(ifname, SIOCGIWRANGE, &wrq) >= 0)
+	{
+		bl = 0;
+
+		for(i = 0; i < range.num_frequency; i++)
+		{
+			entry.mhz        = iwath_freq2mhz(&range.freq[i]);
+			entry.channel    = range.freq[i].i;
+			entry.restricted = 0;
+
+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
+			bl += sizeof(struct iwinfo_freqlist_entry);
+		}
+
+		*len = bl;
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_country(const char *ifname, char *buf)
+{
+	sprintf(buf, "00");
+	return 0;
+}
+
+static int iwath_get_countrylist(const char *ifname, char *buf, int *len)
+{
+	/* Stub */
+	return -1;
+}
+
+static int iwath_get_hwmodelist(const char *ifname, int *buf)
+{
+	char chans[IWINFO_BUFSIZE] = { 0 };
+	struct iwinfo_freqlist_entry *e = NULL;
+	int len = 0;
+
+	*buf = 0;
+
+	if( !iwath_get_freqlist(ifname, chans, &len) )
+	{
+		for( e = (struct iwinfo_freqlist_entry *)chans; e->channel; e++ )
+		{
+			if( e->channel <= 14 )
+			{
+				*buf |= IWINFO_80211_B;
+				*buf |= IWINFO_80211_G;
+			}
+			else
+			{
+				*buf |= IWINFO_80211_A;
+			}
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int iwath_get_htmodelist(const char *ifname, int *buf)
+{
+	/* Stub */
+	return -1;
+}
+
+static int iwath_get_encryption(const char *ifname, char *buf)
+{
+	/* No reliable crypto info in wext */
+	return -1;
+}
+
+static int iwath_get_phyname(const char *ifname, char *buf)
+{
+	/* No suitable api in wext */
+	strcpy(buf, ifname);
+	return 0;
+}
+
+static int iwath_get_mbssid_support(const char *ifname, int *buf)
+{
+	/* No multi bssid support atm */
+	return -1;
+}
+
+static char * iwath_sysfs_ifname_file(const char *ifname, const char *path)
+{
+	FILE *f;
+	static char buf[128];
+	char *rv = NULL;
+
+	snprintf(buf, sizeof(buf), "/sys/class/net/%s/%s", ifname, path);
+
+	if ((f = fopen(buf, "r")) != NULL)
+	{
+		memset(buf, 0, sizeof(buf));
+
+		if (fread(buf, 1, sizeof(buf), f))
+			rv = buf;
+
+		fclose(f);
+	}
+
+	return rv;
+}
+
+static int iwath_get_hardware_id(const char *ifname, char *buf)
+{
+	char *data;
+	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
+
+	memset(id, 0, sizeof(struct iwinfo_hardware_id));
+
+	data = iwath_sysfs_ifname_file(ifname, "device/vendor");
+	if (data)
+		id->vendor_id = strtoul(data, NULL, 16);
+
+	data = iwath_sysfs_ifname_file(ifname, "device/device");
+	if (data)
+		id->device_id = strtoul(data, NULL, 16);
+
+	data = iwath_sysfs_ifname_file(ifname, "device/subsystem_device");
+	if (data)
+		id->subsystem_device_id = strtoul(data, NULL, 16);
+
+	data = iwath_sysfs_ifname_file(ifname, "device/subsystem_vendor");
+	if (data)
+		id->subsystem_vendor_id = strtoul(data, NULL, 16);
+
+	return (id->vendor_id > 0 && id->device_id > 0) ? 0 : -1;
+}
+
+static int iwath_get_hardware_name(const char *ifname, char *buf)
+{
+	sprintf(buf, "Anlix Atheros");
+	return 0;
+}
+
+static int iwath_get_txpower_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
+
+static int iwath_get_frequency_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
+
+const struct iwinfo_ops iwath_ops = {
+	.name             = "ath",
+	.probe            = iwath_probe,
+	.channel          = iwath_get_channel,
+	.center_chan1     = iwath_get_center_chan1,
+	.center_chan2     = iwath_get_center_chan2,
+	.frequency        = iwath_get_frequency,
+	.frequency_offset = iwath_get_frequency_offset,
+	.txpower          = iwath_get_txpower,
+	.txpower_offset   = iwath_get_txpower_offset,
+	.bitrate          = iwath_get_bitrate,
+	.signal           = iwath_get_signal,
+	.noise            = iwath_get_noise,
+	.quality          = iwath_get_quality,
+	.quality_max      = iwath_get_quality_max,
+	.mbssid_support   = iwath_get_mbssid_support,
+	.hwmodelist       = iwath_get_hwmodelist,
+	.htmodelist       = iwath_get_htmodelist,
+	.mode             = iwath_get_mode,
+	.ssid             = iwath_get_ssid,
+	.bssid            = iwath_get_bssid,
+	.country          = iwath_get_country,
+	.hardware_id      = iwath_get_hardware_id,
+	.hardware_name    = iwath_get_hardware_name,
+	.encryption       = iwath_get_encryption,
+	.phyname          = iwath_get_phyname,
+	.assoclist        = iwath_get_assoclist,
+	.txpwrlist        = iwath_get_txpwrlist,
+	.scanlist         = wext_get_scanlist,
+	.freqlist         = iwath_get_freqlist,
+	.countrylist      = iwath_get_countrylist,
+	.close            = iwath_close
+};
diff -Nuar temp_old/iwinfo_lib.c temp_new/iwinfo_lib.c
--- temp_old/iwinfo_lib.c	2022-01-24 10:58:10.334346258 -0300
+++ temp_new/iwinfo_lib.c	2022-01-24 10:58:10.338346131 -0300
@@ -337,6 +337,9 @@
 #ifdef USE_RAMIPS
 	&ramips_ops,
 #endif
+#ifdef USE_ATH
+	&iwath_ops,
+#endif
 	&wext_ops,
 };
 
diff -Nuar temp_old/Makefile temp_new/Makefile
--- temp_old/Makefile	2022-01-24 10:58:10.326346511 -0300
+++ temp_new/Makefile	2022-01-24 10:58:10.330346385 -0300
@@ -32,6 +32,11 @@
 	IWINFO_LIB_OBJ += iwinfo_ramips.o
 endif
 
+ifneq ($(filter ath,$(IWINFO_BACKENDS)),)
+	IWINFO_CFLAGS  += -DUSE_ATH
+	IWINFO_LIB_OBJ += iwinfo_ath.o
+endif
+
 ifneq ($(filter nl80211,$(IWINFO_BACKENDS)),)
 	IWINFO_CFLAGS      += -DUSE_NL80211
 	IWINFO_CLI_LDFLAGS += -lnl-tiny
